#include "ds18b20.h"

char dt_testdevice(void) //функция определения датчика на шине
{
	char stektemp=SREG;// сохраним значение стека
	cli(); //запрещаем прерывания
	char dt;
	
	DDRTEMP |= 1<<BITTEMP; //притягиваем шину
	_delay_us(485); //задержка как минимум на 480 микросекунд
	DDRTEMP &= ~(1<<BITTEMP); //отпускаем шину
	_delay_us(65); //задержка как минимум на 60 микросекунд
	if((PINTEMP & (1<<BITTEMP))==0)//проверяем, ответит ли устройство
	{
		PORTD |= (1<<4);
		dt=1;//устройство есть
	}
	else dt=0;//устройства нет
	
	SREG = stektemp;// вернем значение стека
	_delay_us(420); //задержка как минимум на 480 микросекунд, но хватит и 420, тк это с учетом времени прошедших команд
	return dt; //вернем результат
}

void dt_sendbit(char bt)
{
	char stektemp=SREG;// сохраним значение стека
	cli(); //запрещаем прерывание
	DDRTEMP |= 1<<BITTEMP; //притягиваем шину
	_delay_us(2); //задержка как минимум на 2 микросекунды
	if(bt)
	DDRTEMP &= ~(1<<BITTEMP); //отпускаем шину
	_delay_us(65); //задержка как минимум на 60 микросекунд
	DDRTEMP &= ~(1<<BITTEMP); //отпускаем шину
	SREG = stektemp;// вернем значение стека
}

void dt_sendbyte(unsigned char bt)//функция записи байта на устройство
{
	char i;
	for(i=0;i<8;i++)//посылаем отдельно каждый бит на устройство
	{
		if((bt & (1<<i)) == 1<<i)//посылаем 1
		{
			dt_sendbit(1);
			} else {//посылаем 0
			dt_sendbit(0);
		}
	}
}

char dt_readbit(void)//функция чтения бита с устройства
{
	char stektemp=SREG;// сохраним значение стека
	cli(); //запрещаем прерывание
	char bt; //переменная хранения бита
	
	DDRTEMP |= 1<<BITTEMP; //притягиваем шину
	_delay_us(2); //задержка как минимум на 2 микросекунды
	DDRTEMP &= ~(1<<BITTEMP); //отпускаем шину
	_delay_us(13);
	bt = (PINTEMP & (1<<BITTEMP))>>BITTEMP; //читаем бит
	_delay_us(45);
	SREG = stektemp;// вернем значение стека
	return bt; //вернем результат
}


unsigned char dt_readbyte(void)//функция чтения байта с устройства
{
	char c=0;
	char i;

	for(i=0;i<8;i++)
	c|=dt_readbit()<<i; //читаем бит

	return c;
}

int dt_check(void) //функция преобразования показаний датчика в температуру
{
	uint8_t bt;//переменная для считывания байта
	int tt=0;
	if(dt_testdevice()==1) //если устройство нашлось
	{
		dt_sendbyte(NOID);//пропустить идентификацию, тк у нас только одно устройство на шине
		dt_sendbyte(T_CONVERT);//измеряем температуру
		_delay_ms(750);//в 12битном режиме преобразования — 750 милисекунд
		
		dt_testdevice(); //снова используем те же манипуляции с шиной что и при проверке ее присутствия
		dt_sendbyte(NOID); //пропустить идентификацию, тк у нас только одно устройство на шине
		dt_sendbyte(READ_DATA); //даем команду на чтение данных с устройства
		
		bt = dt_readbyte(); //читаем младший бит
		tt = dt_readbyte(); //читаем старший бит MS
		tt = (short)(tt<<8)|bt;//сдвигаем старший влево, младший пишем на его место, тем самым получаем общий результат
	}
	return tt;
}

float converttemp (int tt)//преобразование температуры в единицы
{
	float result = 0x00;
	result = (float) tt / 16.0f;
	sei();
	return result;
}
